## 题目

```c++
有5只猴子在海边发现一堆桃子,决定第二天来平分.
第二天清晨,第一只猴子最早来到,它左分右分分不开,就朝海里扔了一只,恰好可以分成5份,它拿上自己的一份走了.
第2,3,4,5只猴子也遇到同样的问题,采用了同样的方法,都是扔掉一只后,恰好可以分成5份.
问这堆桃子至少有多少只.
```

## 思路分析

### **一般性的解法**

然后对于这道题思考，我能给出一个公式，会按如下设
设a为最后的结果,x为开始的结果
则： a = ((((((x-1)*4/5-1)*4/5)-1)*4/5-1)*4/5-1)*4/5
通过如上公式，就能实现算出最后的结果
然后注意结果的筛选

我们的思路是这样的，对每个X（整数）遍历进行通过如上公式的计算，然后算出a，当然 a能为带小数的形式，也能为整数形式，而整数形式的a即为所求。
------------------------------------------------
### **常规思路**

> 设有n个桃子
> n=5k1+1
> 4k1=5k2+1
> 4k2=5k3+1
> 4k3=5k4+1
> 4k4=5k5+1
> k1=5/4k2+1/4
> =5/4[5/4k3+1/4]+1/4=(5/4)^2k3+9/16
> =(5/4)^2[5/4K4+1/4)+9/16
> =(5/4)^3k4+61/64
> =(5/4)^3[(5/4)k5+1/4]+61/64
> =(5/4)4k5+125/256+244/256=(5/4)4k5+369/256
> n=5k1+1
> =5*(5/4)^4k5+5369/256+1
> =5^5/256k5+5366/256+1
> =[5^5k5+5369+256]/256
> ==n是整数==。需5^4k5+369是256的倍数即625k5+369=256k
> 625k5=256k-369=256(k+1)-625
> k+1必须是625的倍数，令k+1=625
> 得625k5=255625
> k5=255,625k5+369=256k=256624
> n=5*[625k5+369+256]/256=[5256624+256]/256=5*624+1=3121堆桃子至少有3121只

## 解法

### 循环方法

```c++
#include <iostream>
using namespace std;
int main(){
    for(int i=1;i<10000;i++){           //从1到10000作循环
        float res = i;
        for(int j=0;j<5;j++){
            res = (res-1)*4/5;
        }
        int temp =(int)res;//强制类型转换
        if(temp==res){
            cout<<i<<" "<<res<<endl;
        }
    }
}
```

### 巧解

> 巧解也是真的很巧，会满足这样一个条件，每次多出来一个，每次剩4/5，这样1为1/5的分子，这样就满足了
>
> 我们试试看给原来的桃子增添 4 个桃子
> 原来多一个，现在加了4个，变成多5个，所有的桃子可以5等分了
> 所以我们可以设桃子数目为x
> 则：
> ==(x+4)*(五分之四的5次方) = 一个整数==
> 所以(1024/3125)*（x+4）应该为一个整数，所以x最小为 3121
>
> 通过上面的一般方法得到的解也可以看到,X+4的值为3215的倍数.==那么只需要保证（n+4）每次都被5整除。即(n+4)/(5^5)为整数。那么就是求其最小整数时，n的取值。即3121.==

#### 递推思路

> 假设取完i次时，桃子数量为A[i]，初始为A[0]；
> 得到递推公式 A[i+1] = (A[i] - 1) * 4 / 5；
> 5 *A[i+1] = (A[i] - 1) * 4； ①
> 求通项公式；
> 先构造辅助数列 B[i+1] = B[i] * 4 / 5;
> 令B[i] = A[i] + x; ②
> 将②式带入①式，求得 x = 4;
> 得B[i] = A[i] + 4;
> 易得 B[i] = B[0] * ( 4 / 5) ^ i ;
> 当i<=5时，由于A[i]均为整数， B[i]也均为整数。
> B[5] = B[0] * 256 / 3125;
> 可得B[0]最小值为3125；
> A[0]最小值 = B[0] - 4 = 3121;
> 可得答案即为3121。

> 先给这些猴子4个桃子，  
>
> 第1只猴子多了4个桃子正好分成五份，拿走自己的部分（一堆多1个，给他的4个桃子留给第二个猴子）；    
>
> 第2只猴子多了4个桃子正好分成五份，拿走自己的部分（一堆多1个，给他的4个桃子留给第三个猴子）；  
>
> …………………
>
> 第5只猴子多了4个桃子正好分成五份，拿走自己的部分；    
>
> 这就是说，有了这4个桃子，每次猴子都可以平均分成5份，可见，原来的总数必须是5的5次方的倍数，即3125，所以原来有3121个。
>
> 先给四个的目的是凑整，这样就当做扔掉的也被第一个拿走了，这样每次都可以除尽。5只猴子需要除尽五次，所以需要5^5次方。那么可列式x+4=5^5解决。
>
> 在这里，每只猴子都取剩下的m个苹果和平分的那些，不妨令每只猴子拿走了这样，这样的话先添加(n-1)*m个苹果，这样虽然第一只猴子拿掉了m+x/n个苹果，但是预先给的没有拿走，对于第二只猴子仍然满足平分，n只猴子平分完还可以再平分，也就是n^(n+1)，所以可列式x+(n-1)*m=n^(n+1)

#### 代码

```c++
#include<algorithm>
 
#include<iostream>
 
#include<cstring>
 
#include<string>
 
#include<map>
 
#include<cmath>
 
 
 
 
using namespace std;
 
typedef long long ll;
 
const int maxn = 1e6+50;
 
 
 
int main(){
 
            ll n,m;
 
            cin >> n >> m;
 
            ll ans = pow(n,n+1)-(n-1)*m;
 
            cout << ans << endl;
 
            return 0;
 
}
```

