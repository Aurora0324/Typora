## 问题

> ```
> 问题描述
> 秋天到了，n只猴子采摘了一大堆苹果放到山洞里，约定第二天平分。这些猴子很崇拜猴王孙悟空，所以都想给他留一些苹果。第一只猴子悄悄来到山洞，把苹果平均分成n份，把剩下的m个苹果吃了,然后藏起来一份，最后把剩下的苹果重新合在一起。这些猴子依次悄悄来到山洞，都做同样的操作，恰好每次都剩下了m个苹果。第二天，这些猴子来到山洞，把剩下的苹果分成n分，巧了，还是剩下了m个。问，原来这些猴子至少采了多少个苹果。
> 
> > 输入格式
> > 两个整数，N M
> >
> > 输出格式
> > 一个整数，表示原来苹果的数目
> >
> > 样例输入
> > 5 1
> >
> > 样例输出
> > 15621
> >
> > 数据规模和约定
> > 0<m<n<9
> ```

## 分析

设苹果的总数为X，向里添加（N-1）*M个苹果，这时，苹果能被每一个猴子均分。

没有剩下的，每个猴子都别吃！

==!!!巧解法==


第一个猴子分苹果的总数：X

拿走[X+(N-1)*M ]/N 个苹果

---

第二个猴子分苹果的总数：(X+(N-1)M) (N-1) /N

拿走(X+(N-1)*M)(N-1)/N^2^ 个苹果

---

第三个猴子分苹果的总数：(X+(N-1)M) (N-1)^2^ /N

拿走(X+(N-1)*M)(N-1) ^2^/N^3^个苹果

---

…
最后一只猴子

拿走(X+(N-1)*M)(N-1)^(N-1)^/N^n^^

---

然后合起来藏起的每一份！！！
<u>最后还分配一次</u>

是 **(X+(N-1)*M)(N-1) ^N^/n^(N+1）^**

---

结果相除一定是一个常数，因为 （N-1）^N^与N^N+1^ 是永远也无法除成**整数**的，说明X+(N-1)*M与N^N+1^是能够整除的。题目中说的是至少，这时我们不妨设他们整除的结果为1，求解便得：X=N(N+1) –(N-1)M

```c
# include<stdio.h>
# include<math.h>
int main()
{
 int n,m,sum;
 scanf("%d %d",&n,&m);
 sum = (int)pow(n, n+1) - (n -1)*m;
 printf("%d",sum);
 return 0;
 } 
```

